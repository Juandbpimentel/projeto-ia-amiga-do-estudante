name: Provision Environment Variables (Vercel + Render)

on:
  workflow_dispatch:

jobs:
  provision:
    runs-on: ubuntu-latest
    environment: production
    # NOTE: Secrets may be stored in repository-level secrets or Environment-level secrets (Settings -> Environments).
    # If you store secrets in GitHub Environments (selected above via 'environment: production'), you must ensure
    # the job has permissions to access them; this workflow will validate presence of critical secrets and provide
    # clear errors if they are missing. Static linters may still warn about 'Context access might be invalid' for
    # environment-scoped secrets even when the workflow is correctly configured.
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      RENDER_TOKEN: ${{ secrets.RENDER_TOKEN }}
      RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
      BACKEND_URL: ${{ secrets.BACKEND_URL }}
      GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      ALLOW_ORIGINS: ${{ secrets.ALLOW_ORIGINS }}
      VERCEL_DEPLOY_HOOK: ${{ secrets.VERCEL_DEPLOY_HOOK }}
      RENDER_DEPLOY_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate required secrets (quick check)
        run: |
          echo "Validating presence of critical secrets..."
          if [ -z "${VERCEL_TOKEN:-}" ]; then echo "Missing VERCEL_TOKEN secret" && exit 1; fi
          if [ -z "${VERCEL_PROJECT_ID:-}" ]; then echo "Missing VERCEL_PROJECT_ID secret" && exit 1; fi
          if [ -z "${RENDER_TOKEN:-}" ]; then echo "Missing RENDER_TOKEN secret" && exit 1; fi
          if [ -z "${RENDER_SERVICE_ID:-}" ]; then echo "Missing RENDER_SERVICE_ID secret" && exit 1; fi
          if [ -z "${BACKEND_URL:-}" ]; then echo "Missing BACKEND_URL secret" && exit 1; fi

      # REMOVIDO: Passo de apt-get (curl e jq já existem nativamente)

      - name: Provision Vercel & Render env vars (idempotent)
        run: |
          set -euo pipefail
          echo "Provisioning env vars in Vercel/Render"

          # --- Helper: Vercel functions ---
          vercel_list_envs() {
            curl -s -H "Authorization: Bearer ${VERCEL_TOKEN}" "https://api.vercel.com/v9/projects/${VERCEL_PROJECT_ID}/env"
          }

          vercel_get_env_id() {
            key="$1"
            vercel_list_envs | jq -r --arg key "$key" '.envs[] | select(.key == $key) | .id' | head -n1
          }

          vercel_create_env() {
            key="$1"; value="$2"; target="${3:-production}"
            # USO DO JQ PARA GERAR JSON SEGURO
            payload=$(jq -n --arg k "$key" --arg v "$value" --arg t "$target" '{key: $k, value: $v, target: [$t]}')
            
            curl -s -X POST "https://api.vercel.com/v9/projects/${VERCEL_PROJECT_ID}/env" \
              -H "Authorization: Bearer ${VERCEL_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$payload"
          }

          vercel_update_env() {
            id="$1"; value="$2"; target="${3:-production}"
            payload=$(jq -n --arg v "$value" --arg t "$target" '{value: $v, target: [$t]}')

            curl -s -X PATCH "https://api.vercel.com/v9/projects/${VERCEL_PROJECT_ID}/env/$id" \
              -H "Authorization: Bearer ${VERCEL_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$payload"
          }

          # --- Helper: Render functions ---
          render_list_envs() {
            curl -s -H "Authorization: Bearer ${RENDER_TOKEN}" "https://api.render.com/v1/services/${RENDER_SERVICE_ID}/env-vars"
          }

          render_get_env_id() {
            key="$1"
            render_list_envs | jq -r --arg key "$key" '.[] | select(.key == $key) | .id' | head -n1
          }

          render_create_env() {
            key="$1"; value="$2"; secure=${3:-true}
            # Correção: secure deve ser boolean cru no JSON, não string, jq lida com isso usando --argjson para booleans se necessário, 
            # mas aqui passamos como string e o jq converte se usarmos a estrutura certa.
            payload=$(jq -n --arg k "$key" --arg v "$value" --argjson s "$secure" '{key: $k, value: $v, secure: $s}')

            curl -s -X POST "https://api.render.com/v1/services/${RENDER_SERVICE_ID}/env-vars" \
              -H "Authorization: Bearer ${RENDER_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$payload"
          }

          render_update_env() {
            id="$1"; value="$2"; secure=${3:-true}
            payload=$(jq -n --arg v "$value" --argjson s "$secure" '{value: $v, secure: $s}')

            curl -s -X PATCH "https://api.render.com/v1/services/${RENDER_SERVICE_ID}/env-vars/$id" \
              -H "Authorization: Bearer ${RENDER_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$payload"
          }

          # --- Lógica de Execução ---

          update_or_create_vercel() {
            key="$1"; value="$2"; target=${3:-production}
            if [ -z "$value" ]; then echo "Skipping Vercel env $key (empty)"; return; fi
            
            id=$(vercel_get_env_id "$key" || echo "")
            if [ -n "$id" ]; then
              echo "Updating Vercel env $key ($id)"
              vercel_update_env "$id" "$value" "$target"
            else
              echo "Creating Vercel env $key"
              vercel_create_env "$key" "$value" "$target"
            fi
          }

          update_or_create_render() {
            key="$1"; value="$2"; secure=${3:-true}
            if [ -z "$value" ]; then echo "Skipping Render env $key (empty)"; return; fi

            id=$(render_get_env_id "$key" || echo "")
            if [ -n "$id" ]; then
              echo "Updating Render env $key ($id)"
              render_update_env "$id" "$value" "$secure"
            else
              echo "Creating Render env $key"
              render_create_env "$key" "$value" "$secure"
            fi
          }

          # Provisionamento
          update_or_create_vercel BACKEND_URL "${BACKEND_URL}"
          update_or_create_vercel NEXT_PUBLIC_BACKEND_URL "${BACKEND_URL}"

          update_or_create_render BACKEND_URL "${BACKEND_URL}" true

          if [ -n "${GOOGLE_API_KEY:-}" ]; then
            update_or_create_render GOOGLE_API_KEY "${GOOGLE_API_KEY}" true
          fi
          if [ -n "${ALLOW_ORIGINS:-}" ]; then
            update_or_create_render ALLOW_ORIGINS "${ALLOW_ORIGINS}" false
          fi

      - name: Trigger Vercel production deployment (hook first, fallback to API)
        run: |
          set -euo pipefail
          if [ -n "${VERCEL_DEPLOY_HOOK:-}" ]; then
            echo "Triggering Vercel deployment via Deploy Hook"
            response=$(curl -s -o /dev/null -w "%{http_code}" -X POST "${VERCEL_DEPLOY_HOOK}")
            if [ "$response" -ge 200 ] && [ "$response" -lt 300 ]; then
              echo "Vercel hook triggered (status $response)"
            else
              echo "Failed to trigger Vercel hook; HTTP status $response" >&2
              exit 1
            fi
            exit 0
          fi
          if [ -z "${VERCEL_TOKEN:-}" ] || [ -z "${VERCEL_PROJECT_ID:-}" ]; then
            echo "VERCEL_TOKEN or VERCEL_PROJECT_ID is missing in secrets; skipping Vercel deployment"
            exit 0
          fi
          echo "Triggering Vercel deployment for project $VERCEL_PROJECT_ID"
          # Ensure jq exists
          if ! command -v jq >/dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
          ref=${GITHUB_REF#refs/heads/}
          # For API fallback: use project id correctly in the payload and ensure gitSource repo matches
          payload=$(jq -n --arg project "$VERCEL_PROJECT_ID" --arg repo "$GITHUB_REPOSITORY" --arg ref "$ref" --arg sha "$GITHUB_SHA" '{project: $project, target: "production", gitSource: { type: "github", repoId: $repo, ref: $ref, sha: $sha }}')
          # API fallback with retries (exponential backoff)
          max_attempts=3
          attempt=1
          url=""
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt to create Vercel deployment via API..."
            response=$(curl -s -X POST "https://api.vercel.com/v13/deployments" \
              -H "Authorization: Bearer ${VERCEL_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$payload") || true
            url=$(echo "$response" | jq -r '.url // empty' 2>/dev/null || true)
            if [ -n "$url" ]; then
              echo "Vercel deployment created: https://$url"
              break
            fi
            echo "Vercel API response: $response"
            sleep_time=$((attempt * 2))
            echo "Sleeping $sleep_time seconds before retry"
            sleep $sleep_time
            attempt=$((attempt + 1))
          done
          if [ -z "$url" ]; then
            echo "Failed to create Vercel deployment after $max_attempts attempts; response: $response"
            exit 1
          fi
      - name: Trigger Render deployment (hook first, fallback to API)
        run: |
          set -euo pipefail
          if [ -z "${RENDER_TOKEN:-}" ] || [ -z "${RENDER_SERVICE_ID:-}" ]; then
            echo "RENDER_TOKEN or RENDER_SERVICE_ID missing; skipping Render deployment"
            exit 0
          fi
      - name: Confirm Render envs (keys only)
        run: |
          set -euo pipefail
          echo "Listing Render env var keys for ${RENDER_SERVICE_ID} (keys only, values hidden)..."
          keys=$(curl -s -H "Authorization: Bearer ${RENDER_TOKEN}" "https://api.render.com/v1/services/${RENDER_SERVICE_ID}/env-vars" | jq -r '.[].key' || true)
          echo "$keys"
          if echo "$keys" | grep -q '^GOOGLE_API_KEY$'; then
            echo "GOOGLE_API_KEY is present on Render service"
          else
            echo "GOOGLE_API_KEY is not present on Render service"
          fi
              echo "Triggering Render deployment for service ${RENDER_SERVICE_ID}"
          # Use hook when available to avoid API auth complexities
          if [ -n "${RENDER_DEPLOY_HOOK:-}" ]; then
            echo "Triggering Render deploy via Deploy Hook"
            status=$(curl -s -o /dev/null -w "%{http_code}" -X POST "${RENDER_DEPLOY_HOOK}")
            if [ "$status" -ge 200 ] && [ "$status" -lt 300 ]; then
              echo "Render deploy hook triggered (status $status)"
            else
              echo "Render deploy hook failed with status $status" >&2
              exit 1
            fi
            exit 0
          fi
          # API fallback with retries (exponential backoff)
          max_attempts=3
          attempt=1
          id=""
          response=""
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt to create Render deployment via API..."
            response=$(curl -s -X POST "https://api.render.com/v1/services/${RENDER_SERVICE_ID}/deploys" \
              -H "Authorization: Bearer ${RENDER_TOKEN}" \
              -H "Content-Type: application/json" \
              -d '{}') || true
            id=$(echo "$response" | jq -r '.id // empty' 2>/dev/null || true)
            state=$(echo "$response" | jq -r '.state // empty' 2>/dev/null || true)
            if [ -n "$id" ]; then
              echo "Render deployment created: id=$id, state=$state"
              echo "Render deploy response: $response" | jq -r .
              break
            fi
            echo "Render API response: $response"
            sleep_time=$((attempt * 2))
            echo "Sleeping $sleep_time seconds before retry"
            sleep $sleep_time
            attempt=$((attempt + 1))
          done
          if [ -z "$id" ]; then
            echo "Failed to create Render deployment after $max_attempts attempts; response: $response"
            exit 1
          fi
